<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>library.viz API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>library.viz</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from Bio.PDB.Atom import Atom
from Bio.PDB.Model import Model
from Bio.PDB.Chain import Chain
from Bio.PDB.Residue import Residue
from Bio.PDB.Structure import Structure
from Bio.PDB.NeighborSearch import NeighborSearch

from library.classes import dataset
from library.parser import get_cg_at_datasets
from library.static.utils import DEFAULT_ELEMENT_COLOR_MAP
from library.static.topologies import cg_name_to_type_dict, cg_bond_map_dict

import os
import matplotlib.pyplot as plt
import numpy as np


def __get_name(atom: Atom):
    return atom.get_name()


def __get_element(atom: Atom):
    return atom.element


def plot_residue(
    residue: Residue,
    residue_map=None,
    bond_map=None,
    show_labels=False,
    group_by_element=False,
    show_neighrbor_bonds=False,
    neighbor_distance=0.5,
    save_path=None,
    dont_show_plot=False,
    ax=None,
    fig=None
) -&gt; plt.Figure:
    &#34;&#34;&#34;
        Plots the residue using matplotlib

        Parameters:
            residue (Residue): The residue to plot
            map (dict): A dictionary mapping atom names to type
            bond_map (dict): A set mapping atom i to atom j if they are bonded
            show_labels (bool): If True, the atoms will be labeled
            group_by_element (bool): If True, the atoms will be colored by their element
            show_neighrbor_bonds (bool): If True, the bonds (estimated) will be shown
            neighbor_distance (float): The distance to search for neighbors
            save_path (str): The path to save the plot to, will not show the plot if given
            dont_show_plot (bool): If True, the plot will not be shown
            ax (matplotlib.axes.Axes): The axes to plot on (must be given if fig is given)
            fig (matplotlib.figure.Figure): The figure to plot on (must be given if ax is given)

        Returns:
            fig (matplotlib.figure.Figure): The figure object
    &#34;&#34;&#34;

    if not isinstance(residue, Residue):
        raise TypeError(&#39;residue must be of type Residue&#39;)

    atom_id = __get_element if group_by_element else __get_name

    # Get the coordinates of all atoms in the residue
    coordinates = np.array([atom.get_coord() for atom in residue.get_atoms()])
    x, y, z = coordinates.T

    # Create the figure
    if ax is None and fig is None:
        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)

    # Set the labels
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Y&#39;)
    ax.set_zlabel(&#39;Z&#39;)

    # Dict for random colors for each atom type
    color_map = {}

    if residue_map is None or group_by_element:
        # Create a random color for each atom type
        for atom in residue.get_atoms():
            if atom_id(atom) not in color_map.keys():
                if atom.element in DEFAULT_ELEMENT_COLOR_MAP.keys():
                    color_map[atom_id(
                        atom)] = DEFAULT_ELEMENT_COLOR_MAP[atom.element]
                else:
                    color_map[atom_id(atom)] = np.random.rand(3,)
    else:
        # Use the given map
        for type in residue_map.keys():
            if residue_map[type] not in color_map.keys():
                color_map[residue_map[type]] = np.random.rand(3,)

    # Color the atoms by their element
    colors = []

    if residue_map is None:
        colors = [color_map[atom_id(atom)] for atom in residue.get_atoms()]
    elif group_by_element:
        if residue_map is not None:
            for atom in residue.get_atoms():
                if atom.element in DEFAULT_ELEMENT_COLOR_MAP.keys():
                    colors.append(DEFAULT_ELEMENT_COLOR_MAP[atom.element])
                else:
                    colors.append(color_map[atom_id(atom)])
        else:
            colors = [color_map[atom_id(atom)] for atom in residue.get_atoms()]
    else:
        colors = [color_map[residue_map[atom.get_name()]]
                  for atom in residue.get_atoms()]

    # Add legend
    ax.legend(handles=[plt.Line2D([0], [0], color=color, linewidth=3, linestyle=&#39;-&#39;)
              for color in color_map.values()
                       ], labels=list(color_map.keys()))

    # Plot the coordinates
    ax.scatter(x, y, z, c=colors, edgecolors=&#39;black&#39;)

    # Add lines between the atoms that are bonded using the bond_map dict i -&gt; j
    if bond_map is not None:
        for i in bond_map.keys():
            if isinstance(bond_map[i], list):
                for j in bond_map[i]:
                    at_from = list(residue.get_atoms())[i - 1]
                    at_to = list(residue.get_atoms())[j - 1]
                    ax.plot([at_from.get_coord()[0], at_to.get_coord()[0]], [
                            at_from.get_coord()[1], at_to.get_coord()[1]], [at_from.get_coord()[2], at_to.get_coord()[2]],
                            color=&#39;black&#39;, linestyle=&#39;--&#39;, linewidth=1)
            else:
                at_from = list(residue.get_atoms())[i - 1]
                at_to = list(residue.get_atoms())[bond_map[i] - 1]
                ax.plot([at_from.get_coord()[0], at_to.get_coord()[0]], [
                        at_from.get_coord()[1], at_to.get_coord()[1]], [at_from.get_coord()[2], at_to.get_coord()[2]],
                        color=&#39;black&#39;, linestyle=&#39;--&#39;, linewidth=1)

    elif show_neighrbor_bonds:
        ns = NeighborSearch(list(residue.get_atoms()))
        for atom in residue.get_atoms():
            neighbors = ns.search(atom.get_coord(), neighbor_distance)
            for neighbor in neighbors:
                ax.plot([atom.get_coord()[0], neighbor.get_coord()[0]], [
                        atom.get_coord()[1], neighbor.get_coord()[1]], [atom.get_coord()[2], neighbor.get_coord()[2]],
                        color=&#39;black&#39;, linestyle=&#39;--&#39;, linewidth=1)

    # Add labels to the atoms if show_labels is True
    if show_labels:
        if residue_map is None or group_by_element:
            for i, atom in enumerate(residue.get_atoms()):
                ax.text(atom.get_coord()[0], atom.get_coord()[
                        1], atom.get_coord()[2], atom_id(atom))
        else:
            for i, atom in enumerate(residue.get_atoms()):
                ax.text(atom.get_coord()[0], atom.get_coord()[
                        1], atom.get_coord()[2], residue_map[atom_id(atom)])

    # Save the plot
    if save_path:
        plt.savefig(save_path)

    # Show the plot
    if not dont_show_plot:
        plt.show()

    return ax


def show_dataset(
    name: str,
    residue_index: int,
    dont_show_plot=False,
):
    # Get all CG and AT datasets
    cg_datasets, at_datasets = get_cg_at_datasets(os.path.join(&#34;data&#34;, &#34;raw&#34;))
    cg_dataset, at_dataset = None, None

    # Find the dataset with the given name
    for dataset in cg_datasets:
        if dataset.parent == name:
            cg_dataset = dataset
            break
    else:
        raise ValueError(f&#34;Could not find dataset with name {name}&#34;)
    
    for dataset in at_datasets:
        if dataset.parent == name:
            at_dataset = dataset
            break
    else:
        raise ValueError(f&#34;Could not find dataset with name {name}&#34;)

    # Bond map for cg system
    cg_residue_map = cg_name_to_type_dict(os.path.join(
        &#34;data&#34;, &#34;topologies&#34;, &#34;martini_v2.0_DOPC_02.itp&#34;))
    cg_bond_map = cg_bond_map_dict(os.path.join(
        &#34;data&#34;, &#34;topologies&#34;, &#34;martini_v2.0_DOPC_02.itp&#34;))

    # Bond map for at system
    at_residue_map = cg_name_to_type_dict(os.path.join(
        &#34;data&#34;, &#34;raw&#34;, &#34;CG2AT_2023-02-13_20-20-52&#34;, &#34;FINAL&#34;, &#34;DOPC.itp&#34;))
    at_bond_map = cg_bond_map_dict(os.path.join(
        &#34;data&#34;, &#34;raw&#34;, &#34;CG2AT_2023-02-13_20-20-52&#34;, &#34;FINAL&#34;, &#34;DOPC.itp&#34;))

    # Create Folder if it does not exist
    if not os.path.exists(os.path.join(&#34;data&#34;, &#34;figures&#34;, &#34;raw_data&#34;, cg_dataset.parent)):
        os.makedirs(os.path.join(&#34;data&#34;, &#34;figures&#34;,
                                    &#34;raw_data&#34;, cg_dataset.parent))

    for i, (cg_residue, at_residue) in enumerate(zip(cg_dataset.get_residues(), at_dataset.get_residues())):
        if i == residue_index:
            # Plot the figures side by side
            fig = plt.figure(figsize=(10, 5))
            ax1 = fig.add_subplot(121, projection=&#39;3d&#39;)
            ax2 = fig.add_subplot(122, projection=&#39;3d&#39;)

            plot_residue(cg_residue,
                            residue_map=cg_residue_map, bond_map=cg_bond_map, show_labels=True, group_by_element=True, dont_show_plot=True, ax=ax1, fig=fig)

            plot_residue(at_residue, residue_map=at_residue_map,
                            bond_map=at_bond_map, show_labels=False, group_by_element=True, dont_show_plot=True, ax=ax2, fig=fig)

            # Add title
            fig.suptitle(f&#39;CG vs AT ({cg_dataset.parent})&#39;, fontsize=16)

            # Save the figure
            if not dont_show_plot:
                plt.show()
            else:
                plt.savefig(os.path.join(f&#34;{cg_dataset.parent}-{i}.png&#34;))
                print(f&#34;Saved figure to {os.path.join(f&#39;{cg_dataset.parent}-{i}.png&#39;)}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="library.viz.plot_residue"><code class="name flex">
<span>def <span class="ident">plot_residue</span></span>(<span>residue: Bio.PDB.Residue.Residue, residue_map=None, bond_map=None, show_labels=False, group_by_element=False, show_neighrbor_bonds=False, neighbor_distance=0.5, save_path=None, dont_show_plot=False, ax=None, fig=None) ‑> matplotlib.figure.Figure</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the residue using matplotlib</p>
<h2 id="parameters">Parameters</h2>
<p>residue (Residue): The residue to plot
map (dict): A dictionary mapping atom names to type
bond_map (dict): A set mapping atom i to atom j if they are bonded
show_labels (bool): If True, the atoms will be labeled
group_by_element (bool): If True, the atoms will be colored by their element
show_neighrbor_bonds (bool): If True, the bonds (estimated) will be shown
neighbor_distance (float): The distance to search for neighbors
save_path (str): The path to save the plot to, will not show the plot if given
dont_show_plot (bool): If True, the plot will not be shown
ax (matplotlib.axes.Axes): The axes to plot on (must be given if fig is given)
fig (matplotlib.figure.Figure): The figure to plot on (must be given if ax is given)</p>
<h2 id="returns">Returns</h2>
<p>fig (matplotlib.figure.Figure): The figure object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_residue(
    residue: Residue,
    residue_map=None,
    bond_map=None,
    show_labels=False,
    group_by_element=False,
    show_neighrbor_bonds=False,
    neighbor_distance=0.5,
    save_path=None,
    dont_show_plot=False,
    ax=None,
    fig=None
) -&gt; plt.Figure:
    &#34;&#34;&#34;
        Plots the residue using matplotlib

        Parameters:
            residue (Residue): The residue to plot
            map (dict): A dictionary mapping atom names to type
            bond_map (dict): A set mapping atom i to atom j if they are bonded
            show_labels (bool): If True, the atoms will be labeled
            group_by_element (bool): If True, the atoms will be colored by their element
            show_neighrbor_bonds (bool): If True, the bonds (estimated) will be shown
            neighbor_distance (float): The distance to search for neighbors
            save_path (str): The path to save the plot to, will not show the plot if given
            dont_show_plot (bool): If True, the plot will not be shown
            ax (matplotlib.axes.Axes): The axes to plot on (must be given if fig is given)
            fig (matplotlib.figure.Figure): The figure to plot on (must be given if ax is given)

        Returns:
            fig (matplotlib.figure.Figure): The figure object
    &#34;&#34;&#34;

    if not isinstance(residue, Residue):
        raise TypeError(&#39;residue must be of type Residue&#39;)

    atom_id = __get_element if group_by_element else __get_name

    # Get the coordinates of all atoms in the residue
    coordinates = np.array([atom.get_coord() for atom in residue.get_atoms()])
    x, y, z = coordinates.T

    # Create the figure
    if ax is None and fig is None:
        fig = plt.figure()
        ax = fig.add_subplot(111, projection=&#39;3d&#39;)

    # Set the labels
    ax.set_xlabel(&#39;X&#39;)
    ax.set_ylabel(&#39;Y&#39;)
    ax.set_zlabel(&#39;Z&#39;)

    # Dict for random colors for each atom type
    color_map = {}

    if residue_map is None or group_by_element:
        # Create a random color for each atom type
        for atom in residue.get_atoms():
            if atom_id(atom) not in color_map.keys():
                if atom.element in DEFAULT_ELEMENT_COLOR_MAP.keys():
                    color_map[atom_id(
                        atom)] = DEFAULT_ELEMENT_COLOR_MAP[atom.element]
                else:
                    color_map[atom_id(atom)] = np.random.rand(3,)
    else:
        # Use the given map
        for type in residue_map.keys():
            if residue_map[type] not in color_map.keys():
                color_map[residue_map[type]] = np.random.rand(3,)

    # Color the atoms by their element
    colors = []

    if residue_map is None:
        colors = [color_map[atom_id(atom)] for atom in residue.get_atoms()]
    elif group_by_element:
        if residue_map is not None:
            for atom in residue.get_atoms():
                if atom.element in DEFAULT_ELEMENT_COLOR_MAP.keys():
                    colors.append(DEFAULT_ELEMENT_COLOR_MAP[atom.element])
                else:
                    colors.append(color_map[atom_id(atom)])
        else:
            colors = [color_map[atom_id(atom)] for atom in residue.get_atoms()]
    else:
        colors = [color_map[residue_map[atom.get_name()]]
                  for atom in residue.get_atoms()]

    # Add legend
    ax.legend(handles=[plt.Line2D([0], [0], color=color, linewidth=3, linestyle=&#39;-&#39;)
              for color in color_map.values()
                       ], labels=list(color_map.keys()))

    # Plot the coordinates
    ax.scatter(x, y, z, c=colors, edgecolors=&#39;black&#39;)

    # Add lines between the atoms that are bonded using the bond_map dict i -&gt; j
    if bond_map is not None:
        for i in bond_map.keys():
            if isinstance(bond_map[i], list):
                for j in bond_map[i]:
                    at_from = list(residue.get_atoms())[i - 1]
                    at_to = list(residue.get_atoms())[j - 1]
                    ax.plot([at_from.get_coord()[0], at_to.get_coord()[0]], [
                            at_from.get_coord()[1], at_to.get_coord()[1]], [at_from.get_coord()[2], at_to.get_coord()[2]],
                            color=&#39;black&#39;, linestyle=&#39;--&#39;, linewidth=1)
            else:
                at_from = list(residue.get_atoms())[i - 1]
                at_to = list(residue.get_atoms())[bond_map[i] - 1]
                ax.plot([at_from.get_coord()[0], at_to.get_coord()[0]], [
                        at_from.get_coord()[1], at_to.get_coord()[1]], [at_from.get_coord()[2], at_to.get_coord()[2]],
                        color=&#39;black&#39;, linestyle=&#39;--&#39;, linewidth=1)

    elif show_neighrbor_bonds:
        ns = NeighborSearch(list(residue.get_atoms()))
        for atom in residue.get_atoms():
            neighbors = ns.search(atom.get_coord(), neighbor_distance)
            for neighbor in neighbors:
                ax.plot([atom.get_coord()[0], neighbor.get_coord()[0]], [
                        atom.get_coord()[1], neighbor.get_coord()[1]], [atom.get_coord()[2], neighbor.get_coord()[2]],
                        color=&#39;black&#39;, linestyle=&#39;--&#39;, linewidth=1)

    # Add labels to the atoms if show_labels is True
    if show_labels:
        if residue_map is None or group_by_element:
            for i, atom in enumerate(residue.get_atoms()):
                ax.text(atom.get_coord()[0], atom.get_coord()[
                        1], atom.get_coord()[2], atom_id(atom))
        else:
            for i, atom in enumerate(residue.get_atoms()):
                ax.text(atom.get_coord()[0], atom.get_coord()[
                        1], atom.get_coord()[2], residue_map[atom_id(atom)])

    # Save the plot
    if save_path:
        plt.savefig(save_path)

    # Show the plot
    if not dont_show_plot:
        plt.show()

    return ax</code></pre>
</details>
</dd>
<dt id="library.viz.show_dataset"><code class="name flex">
<span>def <span class="ident">show_dataset</span></span>(<span>name: str, residue_index: int, dont_show_plot=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show_dataset(
    name: str,
    residue_index: int,
    dont_show_plot=False,
):
    # Get all CG and AT datasets
    cg_datasets, at_datasets = get_cg_at_datasets(os.path.join(&#34;data&#34;, &#34;raw&#34;))
    cg_dataset, at_dataset = None, None

    # Find the dataset with the given name
    for dataset in cg_datasets:
        if dataset.parent == name:
            cg_dataset = dataset
            break
    else:
        raise ValueError(f&#34;Could not find dataset with name {name}&#34;)
    
    for dataset in at_datasets:
        if dataset.parent == name:
            at_dataset = dataset
            break
    else:
        raise ValueError(f&#34;Could not find dataset with name {name}&#34;)

    # Bond map for cg system
    cg_residue_map = cg_name_to_type_dict(os.path.join(
        &#34;data&#34;, &#34;topologies&#34;, &#34;martini_v2.0_DOPC_02.itp&#34;))
    cg_bond_map = cg_bond_map_dict(os.path.join(
        &#34;data&#34;, &#34;topologies&#34;, &#34;martini_v2.0_DOPC_02.itp&#34;))

    # Bond map for at system
    at_residue_map = cg_name_to_type_dict(os.path.join(
        &#34;data&#34;, &#34;raw&#34;, &#34;CG2AT_2023-02-13_20-20-52&#34;, &#34;FINAL&#34;, &#34;DOPC.itp&#34;))
    at_bond_map = cg_bond_map_dict(os.path.join(
        &#34;data&#34;, &#34;raw&#34;, &#34;CG2AT_2023-02-13_20-20-52&#34;, &#34;FINAL&#34;, &#34;DOPC.itp&#34;))

    # Create Folder if it does not exist
    if not os.path.exists(os.path.join(&#34;data&#34;, &#34;figures&#34;, &#34;raw_data&#34;, cg_dataset.parent)):
        os.makedirs(os.path.join(&#34;data&#34;, &#34;figures&#34;,
                                    &#34;raw_data&#34;, cg_dataset.parent))

    for i, (cg_residue, at_residue) in enumerate(zip(cg_dataset.get_residues(), at_dataset.get_residues())):
        if i == residue_index:
            # Plot the figures side by side
            fig = plt.figure(figsize=(10, 5))
            ax1 = fig.add_subplot(121, projection=&#39;3d&#39;)
            ax2 = fig.add_subplot(122, projection=&#39;3d&#39;)

            plot_residue(cg_residue,
                            residue_map=cg_residue_map, bond_map=cg_bond_map, show_labels=True, group_by_element=True, dont_show_plot=True, ax=ax1, fig=fig)

            plot_residue(at_residue, residue_map=at_residue_map,
                            bond_map=at_bond_map, show_labels=False, group_by_element=True, dont_show_plot=True, ax=ax2, fig=fig)

            # Add title
            fig.suptitle(f&#39;CG vs AT ({cg_dataset.parent})&#39;, fontsize=16)

            # Save the figure
            if not dont_show_plot:
                plt.show()
            else:
                plt.savefig(os.path.join(f&#34;{cg_dataset.parent}-{i}.png&#34;))
                print(f&#34;Saved figure to {os.path.join(f&#39;{cg_dataset.parent}-{i}.png&#39;)}&#34;)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="library" href="index.html">library</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="library.viz.plot_residue" href="#library.viz.plot_residue">plot_residue</a></code></li>
<li><code><a title="library.viz.show_dataset" href="#library.viz.show_dataset">show_dataset</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>